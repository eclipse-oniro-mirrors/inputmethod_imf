/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!sts_inject_into_module("import {ElementName} from 'bundleManager.ElementName';")
@!sts_inject_into_module("import * as ohos_InputMethodSubtype from './@ohos.InputMethodSubtype';")

@!sts_inject_into_module("""
import { Callback } from '@ohos.base';
import { UIContext } from "@ohos.arkui.UIContext";
""")

@!namespace("@ohos.inputMethod", "inputMethod")

from ohos.inputMethod.Panel use PanelInfo;
from ohos.InputMethodSubtype use InputMethodSubtype;
@!sts_inject("""
static { loadLibrary("inputmethod_taihe_native.z") }
""")

struct MessageHandler {
    onMessage: (msgId: String, @optional msgParam: Optional<@arraybuffer Array<u8>>) => void;
    onTerminated: (data: UndefinedType) => void;
}

@!sts_inject("""
const MAX_TYPE_NUM: int = 128;
""")

enum EnabledState : i32 {
    DISABLED = 0,
    BASIC_MODE = 1,
    FULL_EXPERIENCE_MODE = 2
}

enum CapitalizeMode : i32 {
    NONE = 0,
    SENTENCES = 1,
    WORDS = 2,
    CHARACTERS = 3
}

struct InputMethodProperty {
    @readonly name: String;
    @readonly id: String;
    @readonly label: Optional<String>;
    @readonly labelId: Optional<i64>;
    @readonly icon: Optional<String>;
    @readonly iconId: Optional<i64>;
    @readonly enabledState: Optional<EnabledState>;
    extra: Optional<Opaque>;
}

struct InputWindowInfo {
    name: String;
    left: i32;
    top: i32;
    width: i64;
    height: i64;
    displayId: Optional<i64>;
}

interface InputMethodSetting {
    @gen_async("getInputMethods")
    @gen_promise("getInputMethods")
    GetInputMethodsAsync(enable: bool): Array<InputMethodProperty>;
    @gen_async("listCurrentInputMethodSubtype")
    @gen_promise("listCurrentInputMethodSubtype")
    ListCurrentInputMethodSubtypeSync(): Array<InputMethodSubtype>;
    @gen_async("listInputMethodSubtype")
    @gen_promise("listInputMethodSubtype")
    ListInputMethodSubtypeSync(inputMethodProperty: InputMethodProperty): Array<InputMethodSubtype>;
    @overload("isPanelShown")
    IsPanelShown(panelInfo: PanelInfo): bool;
    @overload("isPanelShown")
    IsPanelShownId(panelInfo: PanelInfo, displayId: i64): bool;

    @gen_async("getAllInputMethods")
    @gen_promise("getAllInputMethods")
    GetAllInputMethodsAsync(): Array<InputMethodProperty>;

    OnImeChange(callback: (inputMethodProperty: InputMethodProperty, inputMethodSubtype: InputMethodSubtype) => void, @sts_last opq: Opaque): void;
    OffImeChange(opq: Optional<@sts_type("Function2<InputMethodProperty, ohos_InputMethodSubtype.InputMethodSubtype, void>") Opaque>): void;

    OnImeShow(callback: (info: Array<InputWindowInfo>) => void, @sts_last opq: Opaque): void;
    OffImeShow(opq: Optional<@sts_type("Function1<Array<InputWindowInfo>, void>") Opaque>): void;

    OnImeHide(callback: (info: Array<InputWindowInfo>) => void, @sts_last opq: Opaque): void;
    OffImeHide(opq: Optional<@sts_type("Function1<Array<InputWindowInfo>, void>") Opaque>): void;

    @gen_promise("getInputMethodState")
    GetInputMethodStateSync(): EnabledState;

    @gen_promise("enableInputMethod")
    EnableInputMethodSync(bundleName: String, extensionName: String, enabledState: EnabledState): void;

    GetInputMethodsSync(enable: bool): Array<InputMethodProperty>;
    GetAllInputMethodsSync(): Array<InputMethodProperty>;
}

struct CursorInfo {
    left: f64;
    top: f64;
    width: f64;
    height: f64;
}

enum Direction : i32 {
    CURSOR_UP = 1,
    CURSOR_DOWN = 2,
    CURSOR_LEFT = 3,
    CURSOR_RIGHT = 4
}

struct Range {
    start: i32;
    end: i32;
}

struct Movement {
    direction : Direction;
}

enum ExtendAction : i32 {
    SELECT_ALL = 0,
    CUT = 3,
    COPY = 4,
    PASTE = 5
}

enum TextInputType : i32 {
    NONE = -1,
    TEXT = 0,
    MULTILINE = 1,
    NUMBER = 2,
    PHONE = 3,
    DATETIME = 4,
    EMAIL_ADDRESS = 5,
    URL = 6,
    VISIBLE_PASSWORD = 7,
    NUMBER_PASSWORD = 8,
    SCREEN_LOCK_PASSWORD = 9,
    USER_NAME = 10,
    NEW_PASSWORD = 11,
    NUMBER_DECIMAL = 12,
    ONE_TIME_CODE = 13
}

enum EnterKeyType : i32 {
    UNSPECIFIED = 0,
    NONE = 1,
    GO = 2,
    SEARCH = 3,
    SEND = 4,
    NEXT = 5,
    DONE = 6,
    PREVIOUS = 7,
    NEWLINE = 8
}

struct FunctionKey {
    enterKeyType : EnterKeyType;
}

struct InputAttribute {
    textInputType: TextInputType;
    enterKeyType: EnterKeyType;
    placeholder: Optional<String>;
    abilityName: Optional<String>;
}

struct TextConfig {
    inputAttribute: InputAttribute;
    cursorInfo: Optional<CursorInfo>;
    selection: Optional<Range>;
    windowId: Optional<i32>;
    newEditBox: Optional<bool>;
    capitalizeMode: Optional<CapitalizeMode>;
}

enum KeyboardStatus : i32 {
    NONE = 0,
    HIDE = 1,
    SHOW = 2
}

enum RequestKeyboardReason : i32 {
    NONE = 0,
    MOUSE = 1,
    TOUCH = 2,
    OTHER = 20
}

union UndefinedType {
  @undefined undefined;
}

struct AttachOptions {
    showKeyboard: Optional<bool>;
    requestKeyboardReason: Optional<RequestKeyboardReason>;
}

interface InputMethodController {
    @gen_async("hideSoftKeyboard")
    @gen_promise("hideSoftKeyboard")
    HideSoftKeyboardSync();

    @gen_promise("hideSoftKeyboard")
    @overload("HideSoftKeyboardId")
    HideSoftKeyboardIdSync(displayId: i64);

    @gen_promise("showTextInput")
    ShowTextInputHasParam(requestKeyboardReason: RequestKeyboardReason);
    @gen_async("showTextInput")
    @gen_promise("showTextInput")
    ShowTextInputSync();
    @gen_async("hideTextInput")
    @gen_promise("hideTextInput")
    HideTextInputSync();
    @gen_async("attach")
    @gen_promise("attach")
    AttachSync(showKeyboard: bool, textConfig: TextConfig);
    @gen_promise("attach")
    AttachWithReason(showKeyboard: bool, textConfig: TextConfig, requestKeyboardReason: RequestKeyboardReason);
    @gen_promise("attachWithUIContext")
    AttachWithUIContextSync(uiContext: @sts_type("UIContext") Opaque, textConfig: TextConfig, attachOptions: Optional<AttachOptions>);
    @gen_async("detach")
    @gen_promise("detach")
    DetachSync();

    OnSelectByRange(callback: (range: Range) => void, @sts_last opq: Opaque): void;
    OffSelectByRange(opq: Optional<@sts_type("Function1<Range, void>") Opaque>);

    OnSelectByMovement(callback: (movement: Movement) => void, @sts_last opq: Opaque);
    OffSelectByMovement(opq: Optional<@sts_type("Function1<Movement, void>") Opaque>);

    OnInsertText(callback: (text: String) => void, @sts_last opq: Opaque);
    OffInsertText(opq: Optional<@sts_type("Function1<String, void>") Opaque>);

    OnDeleteLeft(callback: (f: i32) => void, @sts_last opq: Opaque);
    OffDeleteLeft(opq: Optional<@sts_type("Function1<int, void>") Opaque>);

    OnDeleteRight(callback: (f: i32) => void, @sts_last opq: Opaque);
    OffDeleteRight(opq: Optional<@sts_type("Function1<int, void>") Opaque>);

    OnSendKeyboardStatus(callback: (status: KeyboardStatus) => void, @sts_last opq: Opaque);
    OffSendKeyboardStatus(opq: Optional<@sts_type("Function1<KeyboardStatus, void>") Opaque>);

    OnSendFunctionKey(callback: (key: FunctionKey) => void, @sts_last opq: Opaque);
    OffSendFunctionKey(opq: Optional<@sts_type("Function1<FunctionKey, void>") Opaque>);

    OnMoveCursor(callback: (direction: Direction) => void, @sts_last opq: Opaque);
    OffMoveCursor(opq: Optional<@sts_type("Function1<Direction, void>") Opaque>);

    OnHandleExtendAction(callback: (extendAction: ExtendAction) => void, @sts_last opq: Opaque);
    OffHandleExtendAction(opq: Optional<@sts_type("Function1<ExtendAction, void>") Opaque>);

    OnGetLeftTextOfCursor(callback: (length: i32) => String, @sts_last opq: Opaque);
    OffGetLeftTextOfCursor(opq: Optional<@sts_type("Function1<int, String>") Opaque>);

    OnGetRightTextOfCursor(callback: (length: i32) => String, @sts_last opq: Opaque);
    OffGetRightTextOfCursor(opq: Optional<@sts_type("Function1<int, String>") Opaque>);

    OnGetTextIndexAtCursor(callback: () => i32, @sts_last opq: Opaque);
    OffGetTextIndexAtCursor(opq: Optional<@sts_type("Function0<int>") Opaque>);

    OnSetPreviewText(callback: (text: String, range: Range) => void, @sts_last opq: Opaque);
    OffSetPreviewText(opq: Optional<@sts_type("Function2<String, Range, void>") Opaque>);

    OnFinishTextPreview(callback: (data: UndefinedType) => void, @sts_last opq: Opaque);
    OffFinishTextPreview(opq: Optional<@sts_type("Function1<void, void>") Opaque>);

    @gen_promise("discardTypingText")
    DiscardTypingTextSync(): void;

    @gen_async("setCallingWindow")
    @gen_promise("setCallingWindow")
    SetCallingWindowSync(windowId: i32): void;

    @gen_async("updateCursor")
    @gen_promise("updateCursor")
    UpdateCursorSync(cursorInfo: CursorInfo): void;

    @gen_async("changeSelection")
    @gen_promise("changeSelection")
    ChangeSelectionSync(text: String, start: i32, end: i32): void;

    @gen_async("updateAttribute")
    @gen_promise("updateAttribute")
    UpdateAttributeSync(attribute: InputAttribute): void;

    @gen_async("stopInputSession")
    @gen_promise("stopInputSession")
    StopInputSessionSync(): bool;

    @gen_async("showSoftKeyboard")
    @gen_promise("showSoftKeyboard")
    ShowSoftKeyboardSync(): void;

    @gen_promise("showSoftKeyboard")
    @overload("showSoftKeyboardId")
    ShowSoftKeyboardIdSync(displayId: i64): void;

    @gen_promise("sendMessage")
    SendMessageSync(msgId: String, msgParam: Optional<@arraybuffer Array<u8>>): void;

    recvMessage(msgHandler: Optional<MessageHandler>): void;
}

function GetSetting(): InputMethodSetting;
function GetController(): InputMethodController;
function GetDefaultInputMethod(): InputMethodProperty;
function GetCurrentInputMethod(): InputMethodProperty;
function GetCurrentInputMethodSubtype(): InputMethodSubtype;
function GetSystemInputMethodConfigAbility(): @sts_type("ElementName") Opaque;
@gen_async("switchInputMethod")
@gen_promise("switchInputMethod")
function SwitchInputMethodWithTarget(target: InputMethodProperty): bool;
@gen_promise("switchInputMethod")
function SwitchInputMethodSync(bundleName: String, subtypeId: Optional<String>);
@gen_async("switchCurrentInputMethodSubtype")
@gen_promise("switchCurrentInputMethodSubtype")
function SwitchCurrentInputMethodSubtypeSync(target: InputMethodSubtype): bool;

function SetSimpleKeyboardEnabled(enable: bool): void;

@gen_async("switchCurrentInputMethodAndSubtype")
@gen_promise("switchCurrentInputMethodAndSubtype")
function SwitchCurrentInputMethodAndSubtypeSync(inputMethodProperty: InputMethodProperty, inputMethodSubtype: InputMethodSubtype): bool;

enum AttachFailureReason : i32 {
    CALLER_NOT_FOCUSED = 0,
    IME_ABNORMAL = 1,
    SERVICE_ABNORMAL = 2
}

function OnAttachmentDidFail(callback: (data: AttachFailureReason) => void);
function OffAttachmentDidFail(callback: Optional<(data: AttachFailureReason) => void>);